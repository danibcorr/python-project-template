{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#python-project-template","title":"Python Project Template","text":"<p>Python Project Template provides a ready-to-use structure for Python projects, integrating best practices for code quality, testing and more. It helps developers start new projects quickly with a maintainable and professional foundation.</p> <p>Warning</p> <p>This template is configured for Linux x86_64 systems. For other platforms, you may need to adjust the <code>environments</code> and <code>required-environments</code> settings in <code>pyproject.toml</code>.</p>"},{"location":"index.html#features","title":"Features","text":"<p>The template includes Ruff and Mypy for linting and type checking, keeping code clean and consistent. Bandit handles security scanning to detect potential vulnerabilities, while Complexipy identifies complex functions and modules. Unit testing is covered by Pytest, and documentation is automated with MkDocs deployed via GitHub Pages. Finally, GitHub Actions ties everything together by automating linting, testing, and documentation deployment in CI/CD.</p>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<p>Before starting, ensure that you have required Python installed and a virtual environment set up. It is recommended to create an isolated environment to manage dependencies cleanly. Additionally, ensure that <code>uv</code> is installed in your environment to handle grouped dependency installations.</p> <p>Generate Your Project \u2014 Use Cookiecutter to create a new project from the template and follow the prompts to configure project metadata, package name, and other options:</p> <pre><code>cookiecutter https://github.com/danibcorr/python-project-template.git\n</code></pre> <p>Install Dependencies \u2014 Activate your virtual environment and install all dependencies using the included <code>Makefile</code>. This installs development, testing, and documentation tools as defined in <code>pyproject.toml</code>:</p> <pre><code>make setup\n</code></pre> <p>Run the Pipeline \u2014 Execute the quality pipeline, which includes linting, type checking, complexity checks, and test execution:</p> <pre><code>make pipeline\n</code></pre> <p>Run the Full Workflow (Optional) \u2014 To perform a complete setup including dependency installation, full quality checks, and local documentation preview, ensuring that the project environment is fully prepared for development and validation:</p> <pre><code>make all\n</code></pre>"},{"location":"content/ci-cd.html","title":"Continuous Integration and Continuous Deployment with GitHub Actions","text":""},{"location":"content/ci-cd.html#automation-strategy-overview","title":"Automation Strategy Overview","text":"<p>Continuous integration and continuous deployment are implemented through GitHub Actions using a workflow definition located at <code>.github/workflows/workflow.yml</code>. This workflow serves as the central automation mechanism of the project and orchestrates validation, documentation generation, and release management within a unified pipeline. By integrating these processes, the repository maintains consistency between code changes, documentation, and released artifacts, while reducing manual intervention and operational errors.</p>"},{"location":"content/ci-cd.html#workflow-architecture-and-execution-model","title":"Workflow Architecture and Execution Model","text":"<p>The workflow is organized into distinct jobs, each corresponding to a specific stage of the CI/CD lifecycle. Job execution is controlled by repository events, such as pushes and pull requests, and by branch-specific conditions. The overall design follows a progressive execution model in which preliminary checks are completed first, establishing a stable baseline before documentation deployment and release publication are triggered. This structure ensures that only validated code advances to user-facing outputs.</p>"},{"location":"content/ci-cd.html#environment-initialization-and-dependency-setup","title":"Environment Initialization and Dependency Setup","text":"<p>The initial job is executed on every push and pull request and is responsible for preparing a reproducible execution environment. A Python runtime is provisioned to ensure consistent interpreter behavior across all stages of the pipeline. Subsequently, all dependencies defined in the <code>pipeline</code> group are installed, guaranteeing the availability of the tools required for validation, documentation building, and automation tasks. Any failure during this phase interrupts the workflow, preventing downstream jobs from running under incomplete or unreliable conditions.</p>"},{"location":"content/ci-cd.html#documentation-build-and-deployment","title":"Documentation Build and Deployment","text":"<p>When changes are integrated into the <code>main</code> branch, the workflow triggers a dedicated documentation job. In this stage, MkDocs is used to generate a static documentation site from the project sources, which is then automatically deployed to GitHub Pages. This process ensures that the published documentation accurately reflects the current state of the main codebase.</p> <p>Documentation versioning is handled through <code>mike</code>, which allows multiple versions of the documentation to coexist. Each version corresponds to a specific software release, enabling users to consult documentation aligned with the version they are using. The entire build and deployment process is automated and requires no manual approval once the workflow conditions are satisfied.</p>"},{"location":"content/ci-cd.html#automated-release-management","title":"Automated Release Management","text":"<p>Release creation is also restricted to the <code>main</code> branch and represents the final stage of the CI/CD pipeline. During this phase, the workflow determines the current project version and creates a corresponding GitHub release. Release notes are generated automatically based on changes since the previous release, providing users with a concise and structured summary of updates. Integrating release management into the workflow enforces a direct relationship between the repository state and published versions, reducing discrepancies between source code and distributed artifacts.</p>"},{"location":"content/ci-cd.html#github-pages-configuration-requirements","title":"GitHub Pages Configuration Requirements","text":"<p>For documentation deployment to function correctly, GitHub Pages must be configured to use GitHub Actions as its publication source. This setting is applied in the repository Pages configuration. Once enabled, every push to the <code>main</code> branch automatically triggers the documentation build and deployment defined in the workflow, ensuring continuous alignment between the repository content and its publicly available technical documentation.</p>"},{"location":"content/cookiecutter.html","title":"Cookiecutter","text":""},{"location":"content/cookiecutter.html#introduction-to-cookiecutter","title":"Introduction to Cookiecutter","text":"<p>Cookiecutter is a command-line utility designed to generate project structures from predefined templates. It enables developers to rapidly scaffold new projects by prompting for configuration inputs and customizing the generated files according to the provided responses. This approach ensures consistency across projects, reduces setup time, and enforces best practices and organizational standards in project structure.</p>"},{"location":"content/cookiecutter.html#configuration-variables","title":"Configuration Variables","text":"<p>The customization process is driven by a configuration file, <code>cookiecutter.json</code>, which defines the variables that the template expects. Each variable corresponds to a specific aspect of the project, such as naming conventions, folder structures, or optional features. During project generation, Cookiecutter interactively prompts the user to provide values for these variables, thereby producing a project tailored to the user\u2019s specifications. The main configuration variables include:</p> Variable Description Example <code>project_name</code> Name of the project <code>my-project</code> <code>project_module_name</code> Name of the Python module <code>src</code> <code>project_test_folder_name</code> Name of the folder for tests <code>tests</code> <code>project_version_python</code> Minimum required Python version <code>3.11</code> <code>mkdocs_repo_url</code> URL of the repository for documentation <code>https://github.com/user/repo</code> <code>add_notebooks_folder</code> Option to include a notebooks folder <code>yes</code> / <code>no</code> <code>add_prompts_folder</code> Option to include a prompts folder <code>yes</code> / <code>no</code> <code>add_dev_container_folder</code> Option to include a Dev Container configuration <code>yes</code> / <code>no</code> <code>add_vscode_folder</code> Option to include VS Code configuration <code>yes</code> / <code>no</code> <p>These variables enable fine-grained control over the structure and functionality of the generated project, accommodating different workflows and development environments.</p>"},{"location":"content/cookiecutter.html#project-generation-workflow","title":"Project Generation Workflow","text":"<p>The process of generating a project using Cookiecutter is straightforward. The user executes the <code>cookiecutter</code> command with the URL or local path of the desired template repository. Cookiecutter then sequentially prompts the user to provide values for each configuration variable defined in <code>cookiecutter.json</code>. Once all responses are collected, the tool automatically creates a new project directory populated with files and folders customized according to the provided inputs.</p> <p>For example, executing:</p> <pre><code>cookiecutter https://github.com/danibcorr/python-project-template.git\n</code></pre> <p>initiates the generation process. The user answers the interactive prompts, specifying names, versions, and optional components. Upon completion, a fully scaffolded project appears, reflecting the selected options and ready for immediate development. This automated approach promotes reproducibility, reduces setup errors, and enforces a consistent organizational structure across multiple projects.</p>"},{"location":"content/makefile-commands.html","title":"Makefile","text":""},{"location":"content/makefile-commands.html#overview","title":"Overview","text":"<p>The project includes a <code>Makefile</code> designed to automate routine development tasks. Each command is executed using the syntax <code>make &lt;command&gt;</code> and encapsulates a sequence of actions that standardize workflows, enforce code quality, and simplify maintenance. By centralizing these tasks, the <code>Makefile</code> ensures consistency across development environments and reduces manual errors.</p>"},{"location":"content/makefile-commands.html#environment-setup-make-setup","title":"Environment Setup: <code>make setup</code>","text":"<p>The <code>setup</code> command installs all necessary dependencies and configures pre-commit hooks to enforce code standards automatically. It leverages <code>uv</code>, a high-performance Python package manager, to install the required packages efficiently. Dependency groups include <code>pipeline</code>, which contains tools for testing and linting, and <code>documentation</code>, which includes MkDocs for building project documentation. Pre-commit hooks are configured to validate code before each commit, preventing common errors and maintaining quality. This command should be executed the first time the project is cloned or whenever dependencies are updated.</p> <pre><code>make setup\n</code></pre>"},{"location":"content/makefile-commands.html#cleaning-temporary-files-make-clean-cache-temp-files","title":"Cleaning Temporary Files: <code>make clean-cache-temp-files</code>","text":"<p>This command removes temporary files and caches that may cause inconsistencies or errors during development. Specifically, it deletes compiled Python bytecode (<code>__pycache__/</code>), pytest caches (<code>.pytest_cache/</code>), mypy caches (<code>.mypy_cache/</code>), and other compiled files such as <code>*.pyc</code> and <code>*.pyo</code>. Regular use of this command ensures a clean environment, particularly before running the complete pipeline or debugging unusual behavior.</p> <pre><code>make clean-cache-temp-files\n</code></pre>"},{"location":"content/makefile-commands.html#code-formatting-and-automatic-fixes-make-lint","title":"Code Formatting and Automatic Fixes: <code>make lint</code>","text":"<p>The <code>lint</code> command enforces coding standards and applies automatic fixes to improve code readability and maintainability. It integrates several tools:</p> <ul> <li>isort: Organizes imports alphabetically and categorically.</li> <li>Ruff: A high-performance linter that detects and fixes style issues.</li> </ul> <p>Typical automatic fixes include removing unused imports, correcting spacing and formatting, and reorganizing imports according to PEP 8 conventions. This command is recommended before committing code or when performing routine code cleanup.</p> <pre><code>make lint\n</code></pre>"},{"location":"content/makefile-commands.html#static-and-security-analysis-make-code-check","title":"Static and Security Analysis: <code>make code-check</code>","text":"<p>The <code>code-check</code> command performs an in-depth analysis to identify potential issues in the codebase. It combines multiple tools:</p> <ol> <li>Mypy: A static type checker that validates type annotations and detects mismatched    types before runtime.</li> <li>Complexipy: Measures cyclomatic complexity to identify functions that may be    difficult to maintain or require refactoring.</li> <li>Bandit: Conducts static application security testing (SAST) to identify common    vulnerabilities, such as SQL injection risks, unsafe <code>eval()</code> usage, and hardcoded    credentials. It scans all code excluding test directories.</li> </ol> <p>This command is essential before merging changes into the main branch or during code reviews to ensure robust, maintainable, and secure code.</p> <pre><code>make code-check\n</code></pre>"},{"location":"content/makefile-commands.html#dead-code-detection-make-check-dead-code","title":"Dead Code Detection: <code>make check-dead-code</code>","text":"<p>The <code>check-dead-code</code> command identifies unused or redundant code that can be safely removed. It detects functions that are never called, uninstantiated classes, and variables that are defined but not utilized. Running this command is particularly useful during refactoring or when optimizing the codebase for maintainability.</p> <pre><code>make check-dead-code\n</code></pre>"},{"location":"content/makefile-commands.html#running-unit-tests-make-test","title":"Running Unit Tests: <code>make test</code>","text":"<p>This command executes all unit tests using Pytest. It supports structured test execution via <code>pytest-order</code> and can generate coverage reports if configured. The <code>tests/</code> directory is scanned recursively, ensuring that all modules are tested thoroughly. This command should be run frequently after code modifications to verify correctness.</p> <pre><code>make test\n</code></pre>"},{"location":"content/makefile-commands.html#documentation-management-make-doc","title":"Documentation Management: <code>make doc</code>","text":"<p>The <code>doc</code> command builds and serves project documentation locally using MkDocs. It launches a development server (by default accessible at <code>http://127.0.0.1:8000</code>) and automatically reloads pages when Markdown files are updated. This allows developers to preview documentation as it will appear on GitHub Pages and ensures consistency between local edits and published content.</p> <pre><code>make doc\n</code></pre>"},{"location":"content/makefile-commands.html#pre-commit-validation-make-pre-commit","title":"Pre-Commit Validation: <code>make pre-commit</code>","text":"<p>The <code>pre-commit</code> command runs a subset of the pipeline specifically designed for pre-commit hooks. It sequentially:</p> <ol> <li>Cleans caches and temporary files.</li> <li>Runs linting and formatting.</li> <li>Performs static analysis, complexity measurement, and security scanning.</li> </ol> <p>This command is automatically executed by Git pre-commit hooks to validate code before committing.</p> <pre><code>make pre-commit\n</code></pre>"},{"location":"content/makefile-commands.html#complete-code-quality-pipeline-make-pipeline","title":"Complete Code Quality Pipeline: <code>make pipeline</code>","text":"<p>The <code>pipeline</code> command orchestrates the full sequence of code quality checks and testing. It sequentially:</p> <ol> <li>Cleans caches and temporary files.</li> <li>Runs linting and formatting.</li> <li>Performs static analysis, complexity measurement, and security scanning.</li> <li>Executes all unit tests.</li> </ol> <p>This command is particularly useful before pushing changes to the repository or as part of a continuous integration (CI) workflow.</p> <pre><code>make pipeline\n</code></pre>"},{"location":"content/makefile-commands.html#full-workflow-execution-make-all","title":"Full Workflow Execution: <code>make all</code>","text":"<p>The <code>all</code> command executes the complete project setup and validation workflow. It installs dependencies, runs the full code quality pipeline, and serves the documentation locally. This command provides a comprehensive initialization process, ensuring the development environment is fully configured and all systems are validated.</p> <pre><code>make all\n</code></pre>"},{"location":"content/overview.html","title":"Python Project Template","text":""},{"location":"content/overview.html#overview","title":"Overview","text":"<p>The Python Project Template is a pre-configured, ready-to-use scaffolding designed to accelerate the creation of professional Python projects. It provides a complete directory structure, integrated tooling, and automation mechanisms that enforce modern development best practices. By using this template, developers can immediately focus on implementing functionality rather than spending time on repetitive setup tasks, ensuring that new projects maintain high standards for code quality, testing, security, and documentation.</p>"},{"location":"content/overview.html#target-audience","title":"Target Audience","text":"<p>This template is intended for a wide range of users and project types:</p> <ul> <li>Individual developers seeking to start projects with a professional and standardized   setup from the outset.</li> <li>Development teams aiming to enforce consistent workflows and project structures across   multiple repositories.</li> <li>Projects spanning domains such as data science, machine learning, APIs, Python   libraries, or general-purpose Python applications.</li> </ul> <p>By providing a common foundation, the template reduces onboarding time for new team members and ensures reproducibility across projects.</p>"},{"location":"content/overview.html#key-benefits","title":"Key Benefits","text":"<p>The Python Project Template offers several advantages that streamline development processes and enhance software quality:</p> <ul> <li>Time Efficiency: The template allows developers to initialize a fully configured   project within minutes, avoiding the hours typically spent on manual setup.</li> <li>Ensured Code Quality: Preconfigured tools for linting, static type checking,   complexity analysis, and security evaluation help maintain high-quality, maintainable,   and secure codebases.</li> <li>Automated Documentation: Integration with MkDocs enables immediate generation and   deployment of project documentation to GitHub Pages, ensuring that documentation   remains synchronized with the code.</li> <li>CI/CD Integration: Built-in GitHub Actions workflows automatically perform code   validation, testing, and documentation deployment, reducing manual intervention and   errors.</li> <li>Customizability: Through Cookiecutter, the template can be adapted to specific   project requirements, allowing modification of structure, module names, and optional   components while preserving the standard workflow.</li> </ul> <p>By combining these features, the template not only accelerates project setup but also enforces modern best practices, supporting sustainable, scalable, and maintainable Python development.</p>"},{"location":"content/pre-commit-hooks.html","title":"Pre-Commit Hooks","text":""},{"location":"content/pre-commit-hooks.html#overview","title":"Overview","text":"<p>Pre-commit hooks are automated scripts configured to execute specific validations before a Git commit is finalized. In this project, the pre-commit system is defined in the <code>.pre-commit-config.yaml</code> file. Its primary purpose is to enforce code quality, detect potential errors early, and prevent non-compliant code from entering the repository. By integrating pre-commit hooks into the workflow, the project ensures that all committed changes meet established coding standards and pass essential checks automatically.</p>"},{"location":"content/pre-commit-hooks.html#functionality","title":"Functionality","text":"<p>When a developer attempts to commit changes, the pre-commit system automatically triggers the pre-commit validation pipeline by executing:</p> <pre><code>make pre-commit\n</code></pre> <p>This command performs a comprehensive sequence of actions, including:</p> <ul> <li>Linting and formatting checks to ensure consistent code style.</li> <li>Type validation using Mypy to detect mismatches and type-related errors.</li> <li>Security analysis with Bandit to identify potential vulnerabilities in the code.</li> <li>Complexity analysis with Complexipy to identify overly complex code.</li> </ul> <p>If any of these checks fail, the commit is blocked, thereby preventing problematic code from being added to the repository. Note that tests are not executed during pre-commit to keep the validation fast, but they are run in the full <code>make pipeline</code> command.</p>"},{"location":"content/pre-commit-hooks.html#advantages","title":"Advantages","text":"<p>Integrating pre-commit hooks into the development workflow provides several key benefits:</p> <ul> <li>Quality Enforcement: Only code that passes all validations can be committed,   maintaining a high standard across the codebase.</li> <li>Early Issue Detection: Errors are detected before code is pushed or reviewed,   reducing downstream debugging and rework.</li> <li>Clean Git History: By preventing commits that violate coding standards or fail   tests, the repository maintains a cleaner and more reliable history.</li> </ul>"},{"location":"content/pre-commit-hooks.html#temporary-bypass-not-recommended","title":"Temporary Bypass (Not Recommended)","text":"<p>While it is possible to bypass pre-commit validations using the <code>--no-verify</code> flag:</p> <pre><code>git commit --no-verify -m \"commit message\"\n</code></pre> <p>this approach is discouraged because it undermines the automated quality safeguards and may introduce errors or inconsistencies into the codebase. Pre-commit hooks are intended to be an integral part of the workflow, ensuring that each commit contributes to a robust, secure, and maintainable project.</p>"},{"location":"content/pyproject-configuration.html","title":"<code>pyproject.toml</code> Configuration","text":""},{"location":"content/pyproject-configuration.html#overview","title":"Overview","text":"<p>The <code>pyproject.toml</code> file serves as the central configuration hub for the project, consolidating metadata, dependency management, and tool settings in a single, standardized location. It follows the PEP 621 specification, which defines a uniform format for Python project metadata and facilitates interoperability between tools. By leveraging <code>pyproject.toml</code>, the project achieves modular dependency management, consistent tool behavior, and simplified setup for both development and production environments.</p>"},{"location":"content/pyproject-configuration.html#build-system-build-system-section","title":"Build System: <code>[build-system]</code> Section","text":"<p>Defines the build backend used for packaging:</p> <pre><code>[build-system]\nrequires = [\"uv_build&gt;=0.9.18,&lt;0.10.0\"]\nbuild-backend = \"uv_build\"\n</code></pre> <p>This configuration uses <code>uv_build</code> as the build backend, enabling fast and reliable package building.</p>"},{"location":"content/pyproject-configuration.html#project-metadata-project-section","title":"Project Metadata: <code>[project]</code> Section","text":"<p>The <code>[project]</code> section defines fundamental information about the project:</p> <pre><code>[project]\nname = \"my-project\"\nversion = \"0.0.1\"\ndescription = \"Project description\"\nauthors = [{name = \"Your Name\", email = \"your@email.com\"}]\nlicense = {file = \"LICENSE\"}\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.11\"\nclassifiers = [\n    \"Intended Audience :: Developers\",\n    \"Intended Audience :: Science/Research\",\n    \"Topic :: Scientific/Engineering\",\n    \"Topic :: Software Development\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3 :: Only\",\n]\nkeywords = [\"python\"]\n</code></pre> <p>These fields ensure that packaging tools, dependency managers, and documentation generators can automatically retrieve key project information. The <code>classifiers</code> help categorize the project on PyPI, while <code>keywords</code> improve discoverability.</p>"},{"location":"content/pyproject-configuration.html#uv-configuration-tooluv-section","title":"UV Configuration: <code>[tool.uv]</code> Section","text":"<p>Configures the UV package manager behavior:</p> <pre><code>[tool.uv]\ndefault-groups = \"all\"\ncache-keys = [{ file = \"pyproject.toml\" }, { git = { commit = true } }]\nenvironments = [\n    \"sys_platform == 'linux'\",\n]\nrequired-environments = [\n    \"sys_platform == 'linux' and platform_machine == 'x86_64'\"\n]\n</code></pre> <ul> <li><code>default-groups = \"all\"</code>: Installs all dependency groups by default.</li> <li><code>cache-keys</code>: Defines cache invalidation triggers based on file changes and git   commits.</li> <li><code>environments</code>: Specifies supported platforms (Linux).</li> <li><code>required-environments</code>: Restricts to Linux x86_64 architecture.</li> </ul>"},{"location":"content/pyproject-configuration.html#uv-build-backend-tooluvbuild-backend-section","title":"UV Build Backend: <code>[tool.uv.build-backend]</code> Section","text":"<pre><code>[tool.uv.build-backend]\nmodule-name = \"my_module\"\nmodule-root = \"\"\n</code></pre> <p>Configures the module name and root directory for the build backend.</p>"},{"location":"content/pyproject-configuration.html#dependency-management-dependency-groups-section","title":"Dependency Management: <code>[dependency-groups]</code> Section","text":"<p>Dependencies are organized into logical groups, allowing selective installation based on project requirements. This modular approach supports both development and production workflows.</p>"},{"location":"content/pyproject-configuration.html#pipeline-group-development-tools","title":"<code>pipeline</code> Group: Development Tools","text":"<p>The <code>pipeline</code> group includes tools essential for code quality, testing, security, and automation:</p> <ul> <li><code>bandit</code>: Security analysis tool for detecting common vulnerabilities.</li> <li><code>complexipy</code>: Measures cyclomatic complexity to identify potentially unmaintainable   code.</li> <li><code>mypy</code>: Static type checker to detect type inconsistencies.</li> <li><code>pytest</code> and <code>pytest-order</code>: Frameworks for running unit tests and controlling test   execution order.</li> <li><code>ruff</code>: A high-performance linter and automatic formatter.</li> <li><code>isort</code>: Sorts imports according to standard conventions.</li> <li><code>deadcode</code>: Detects unused or unreachable code.</li> <li><code>pre-commit</code>: Manages Git pre-commit hooks for automated checks.</li> </ul>"},{"location":"content/pyproject-configuration.html#documentation-group-documentation-tools","title":"<code>documentation</code> Group: Documentation Tools","text":"<p>The <code>documentation</code> group contains tools for building and maintaining project documentation:</p> <ul> <li><code>mkdocs</code> and <code>mkdocs-material</code>: Static site generator and material design theme.</li> <li><code>mkdocstrings[python]</code>: Generates API documentation directly from Python docstrings.</li> <li><code>mkdocs-git-revision-date-localized-plugin</code>: Displays last update dates for pages.</li> <li><code>mkdocs-git-authors-plugin</code>: Shows contributors for each page.</li> <li><code>mkdocs-enumerate-headings-plugin</code>: Automatically numbers headings.</li> <li><code>mkdocs-jupyter</code>: Integrates Jupyter notebooks into documentation.</li> <li><code>mkdocs-awesome-nav</code>: Enhances navigation capabilities.</li> <li><code>mike</code>: Provides versioned documentation management.</li> </ul>"},{"location":"content/pyproject-configuration.html#tool-specific-configuration","title":"Tool-Specific Configuration","text":""},{"location":"content/pyproject-configuration.html#ruff-toolruff","title":"Ruff: <code>[tool.ruff]</code>","text":"<p>The Ruff linter is configured to enforce code style, detect errors, and simplify code:</p> <pre><code>[tool.ruff]\nline-length = 88\nindent-width = 4\nexclude = [\".venv\", \"build\", \"dist\", ...]\nextend-exclude = [\"*.ipynb\"]\n</code></pre> <ul> <li><code>line-length = 88</code>: Maximum line length following Black's convention.</li> <li><code>indent-width = 4</code>: Standard Python indentation.</li> <li><code>exclude</code>: Directories to ignore during linting.</li> <li><code>extend-exclude</code>: Additional patterns to exclude (Jupyter notebooks).</li> </ul>"},{"location":"content/pyproject-configuration.html#ruff-lint-rules-toolrufflint","title":"Ruff Lint Rules: <code>[tool.ruff.lint]</code>","text":"<pre><code>[tool.ruff.lint]\nselect = [\"E\", \"F\", \"UP\", \"B\", \"SIM\"]\nignore = [\"E203\"]\n</code></pre> <ul> <li><code>E</code>: Enforces PEP 8 style guidelines.</li> <li><code>F</code>: Detects Pyflakes errors such as unused imports.</li> <li><code>UP</code>: Applies modern Python syntax checks and upgrades.</li> <li><code>B</code>: Detects common programming bugs.</li> <li><code>SIM</code>: Suggests code simplifications to improve readability.</li> <li><code>ignore = [\"E203\"]</code>: Ignores whitespace before ':' (conflicts with Black).</li> </ul>"},{"location":"content/pyproject-configuration.html#ruff-docstring-style-toolrufflintpydocstyle","title":"Ruff Docstring Style: <code>[tool.ruff.lint.pydocstyle]</code>","text":"<pre><code>[tool.ruff.lint.pydocstyle]\nconvention = \"google\"\n</code></pre> <p>Enforces Google-style docstring conventions.</p>"},{"location":"content/pyproject-configuration.html#ruff-formatter-toolruffformat","title":"Ruff Formatter: <code>[tool.ruff.format]</code>","text":"<pre><code>[tool.ruff.format]\nquote-style = \"double\"\nindent-style = \"space\"\nline-ending = \"auto\"\ndocstring-code-format = true\ndocstring-code-line-length = 88\n</code></pre> <p>Configures automatic code formatting with double quotes, space indentation, and formats code blocks within docstrings.</p>"},{"location":"content/pyproject-configuration.html#mypy-toolmypy","title":"Mypy: <code>[tool.mypy]</code>","text":"<p>Mypy performs static type checking, ensuring type safety and consistency:</p> <pre><code>[tool.mypy]\ncheck_untyped_defs = true\nignore_missing_imports = true\nexclude = [\"^(build|dist|venv)\", \".venv/\"]\ncache_dir = \"/dev/null\"\n</code></pre> <ul> <li><code>check_untyped_defs = true</code>: Validates functions even if type annotations are missing.</li> <li><code>ignore_missing_imports = true</code>: Avoids errors for third-party modules without type   stubs.</li> <li><code>exclude</code>: Directories to skip during type checking.</li> <li><code>cache_dir = \"/dev/null\"</code>: Disables caching to avoid stale cache issues.</li> </ul>"},{"location":"content/pyproject-configuration.html#isort-toolisort","title":"isort: <code>[tool.isort]</code>","text":"<p>isort enforces a standardized import order, improving code readability and maintainability:</p> <pre><code>[tool.isort]\nprofile = \"black\"\nknown_first_party = [\"my_module\"]\nsections = [\"FUTURE\", \"STDLIB\", \"THIRDPARTY\", \"FIRSTPARTY\", \"LOCALFOLDER\"]\nimport_heading_stdlib = \"Standard libraries\"\nimport_heading_thirdparty = \"3pps\"\nimport_heading_firstparty = \"Own modules\"\nimport_heading_localfolder = \"Own modules\"\nline_length = 88\ninclude_trailing_comma = true\ncombine_as_imports = true\nskip_glob = [\".venv/*\", \".uv-cache/*\"]\n</code></pre> <p>Imports are grouped as follows:</p> <ol> <li>FUTURE: Future imports (<code>from __future__ import ...</code>).</li> <li>STDLIB: Python standard library modules.</li> <li>THIRDPARTY: External dependencies installed via package managers.</li> <li>FIRSTPARTY: Modules developed within the current project.</li> <li>LOCALFOLDER: Relative imports for local submodules or packages.</li> </ol> <p>The configuration uses Black-compatible formatting with custom section headings for better organization.</p>"},{"location":"content/pyproject-configuration.html#deadcode-tooldeadcode","title":"deadcode: <code>[tool.deadcode]</code>","text":"<p>Detects unused code in the project:</p> <pre><code>[tool.deadcode]\nexclude = [\".venv\", \".uv-cache\", \"tests\"]\n</code></pre> <p>Excludes virtual environments and test directories from dead code analysis.</p>"}]}